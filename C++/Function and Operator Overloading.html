<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Overloading and Operator Overloading in C++</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <h1>Function Overloading and Operator Overloading in C++</h1>
    </header>

    <section>
        <h2>What is Function Overloading?</h2>
        <p><strong>Function Overloading</strong> is a feature in C++ that allows multiple functions to have the same name but differ in the type, number, or sequence of their parameters. It is an example of compile-time (or static) polymorphism.</p>

        <h3>Key Characteristics:</h3>
        <ul>
            <li>Functions must differ in their parameter list (number, type, or both).</li>
            <li>The return type of the function is not considered for overloading.</li>
            <li>Function overloading improves code readability and reusability.</li>
        </ul>

        <h3>Benefits of Function Overloading:</h3>
        <ul>
            <li><strong>Enhanced Code Readability:</strong> Provides a logical grouping of functions with similar behavior.</li>
            <li><strong>Convenience:</strong> Reduces the need to remember multiple function names for similar operations.</li>
            <li><strong>Flexibility:</strong> Allows operations on different data types with the same function name.</li>
        </ul>

        <h3>Example of Function Overloading:</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

class Calculator {
public:
    // Function to add two integers
    int add(int a, int b) {
        return a + b;
    }

    // Function to add three integers
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Function to add two floating-point numbers
    double add(double a, double b) {
        return a + b;
    }
};

int main() {
    Calculator calc;
    cout << "Addition of two integers: " << calc.add(5, 10) << endl;
    cout << "Addition of three integers: " << calc.add(5, 10, 15) << endl;
    cout << "Addition of two doubles: " << calc.add(5.5, 2.3) << endl;
    return 0;
}
        </pre>

        <h3>Output:</h3>
        <pre>
Addition of two integers: 15
Addition of three integers: 30
Addition of two doubles: 7.8
        </pre>
    </section>

    <section>
        <h2>What is Operator Overloading?</h2>
        <p><strong>Operator Overloading</strong> allows programmers to redefine the way operators work for user-defined types. This feature makes it possible to perform operations on objects as though they were primitive data types.</p>

        <h3>Key Characteristics:</h3>
        <ul>
            <li>Only existing operators can be overloaded; new operators cannot be created.</li>
            <li>Operator overloading does not change the precedence or associativity of operators.</li>
            <li>Overloading must be explicitly defined for user-defined types (e.g., classes).</li>
        </ul>

        <h3>Example of Operator Overloading:</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

class Complex {
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // Overloading the + operator
    Complex operator+(const Complex& obj) {
        return Complex(real + obj.real, imag + obj.imag);
    }

    // Overloading the * operator
    Complex operator*(const Complex& obj) {
        return Complex((real * obj.real - imag * obj.imag), (real * obj.imag + imag * obj.real));
    }

    void display() {
        cout << real << " + " << imag << "i" << endl;
    }
};

int main() {
    Complex c1(3.5, 2.5);
    Complex c2(1.5, 3.5);
    Complex c3 = c1 + c2; // Using overloaded + operator
    Complex c4 = c1 * c2; // Using overloaded * operator

    cout << "Complex number 1: ";
    c1.display();
    cout << "Complex number 2: ";
    c2.display();
    cout << "Sum: ";
    c3.display();
    cout << "Product: ";
    c4.display();

    return 0;
}
        </pre>

        <h3>Output:</h3>
        <pre>
Complex number 1: 3.5 + 2.5i
Complex number 2: 1.5 + 3.5i
Sum: 5.0 + 6.0i
Product: -5.25 + 15.0i
        </pre>
    </section>

    <section>
        <h2>Rules for Operator Overloading:</h2>
        <ul>
            <li>Some operators (e.g., <code>::</code>, <code>sizeof</code>, and <code>.</code>) cannot be overloaded.</li>
            <li>Overloaded operators must have at least one operand of a user-defined type.</li>
            <li>Operators can be overloaded as member functions or friend functions.</li>
        </ul>
    </section>

        <section>
        <h2>Advantages of Operator Overloading:</h2>
        <ul>
            <li><strong>Intuitive Usage:</strong> Allows for natural and intuitive manipulation of objects.</li>
            <li><strong>Enhanced Readability:</strong> Simplifies the code by reducing the need for verbose function names.</li>
        </ul>
</section>

<section>
        <h2>Disadvantages:</h2>
        <ul>
            <li>Can lead to confusion if not implemented clearly.</li>
            <li>May obscure the original meaning of operators for developers unfamiliar with the code.</li>
        </ul>
    </section>

    <section>
        <h2>Conclusion:</h2>
        <p>Both function overloading and operator overloading are essential features of C++ that enhance flexibility, readability, and functionality. They allow developers to use familiar operations and interfaces while working with user-defined types, improving code efficiency and maintainability.</p>
    </section>

    <footer>
        <p>Â© By Coding Hub. All Rights Reserved.</p>
    </footer>
</body>
</html>
