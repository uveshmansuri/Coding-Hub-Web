<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Pointers</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>

    <header>
        <h1>C++ Pointers</h1>
    </header>

    <section>
        <h2>What Are Pointers?</h2>
        <p>A <strong>pointer</strong> is a variable that stores the memory address of another variable. In simpler terms, pointers allow us to directly access and manipulate the memory location of a variable. Understanding pointers is crucial for efficient memory management and dynamic memory allocation in C++.</p>

        <h3>Understanding Memory Addresses</h3>
        <p>Each variable in C++ is stored in memory at a specific location, which is known as its memory address. A pointer holds the address of another variable, making it possible to indirectly access and manipulate that variable.</p>

        <p><strong>Example:</strong> If we have an integer variable <code>a</code>, a pointer can store its memory address:</p>
        <pre><code>
int a = 10;    // Declare an integer variable
int *ptr = &a; // Declare a pointer and assign it the address of 'a'
        </code></pre>

        <p>The operator <code>&</code> is used to get the memory address of a variable, while the operator <code>*</code> is used to dereference the pointer (access the value at that memory address).</p>

        <h3>Syntax and Declaration of Pointers</h3>
        <p>The basic syntax for declaring a pointer is:</p>
        <pre><code>
type *pointerName;
        </code></pre>
        <p>Where <code>type</code> is the type of the variable the pointer will point to, and <code>*</code> denotes that it is a pointer. For example, <code>int *ptr;</code> declares a pointer to an integer.</p>

        <h3>Dereferencing a Pointer</h3>
        <p>The <strong>dereference operator</strong> (<code>*</code>) is used to access the value stored at the memory address the pointer is pointing to:</p>
        <pre><code>
int a = 20;
int *ptr = &a;

cout << "Address of a: " << &a << endl;   // Prints the address of 'a'
cout << "Value of a using pointer: " << *ptr << endl; // Dereferencing the pointer
        </code></pre>
        <p><strong>Output:</strong></p>
        <pre><code>
Address of a: 0x7ffee421fd0c
Value of a using pointer: 20
        </code></pre>
    </section>

    <section>
        <h2>Pointer Operations</h2>
        <p>Pointer operations enable powerful memory management features. The common pointer operations are:</p>

        <h3>Pointer Arithmetic</h3>
        <p>C++ allows arithmetic operations on pointers. Pointer arithmetic is based on the size of the type the pointer points to. For example, when incrementing a pointer of type <code>int*</code>, it moves by 4 bytes (on most systems) because an <code>int</code> typically occupies 4 bytes of memory.</p>

        <p><strong>Pointer Arithmetic Operations:</strong></p>
        <ul>
            <li><code>ptr++</code>: Increment pointer by the size of the type it points to.</li>
            <li><code>ptr--</code>: Decrement pointer by the size of the type it points to.</li>
            <li><code>ptr + n</code>: Move pointer forward by <code>n</code> elements.</li>
            <li><code>ptr - n</code>: Move pointer backward by <code>n</code> elements.</li>
        </ul>

        <h3>Example: Pointer Arithmetic</h3>
        <p>The following example demonstrates pointer arithmetic:</p>
        <pre><code>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;  // Pointer to the first element of the array

    // Accessing elements using pointer arithmetic
    cout << "First element: " << *ptr << endl;
    ptr++; // Increment pointer to point to next element
    cout << "Second element: " << *ptr << endl;
    
    ptr += 2; // Move pointer forward by 2 positions
    cout << "Fourth element: " << *ptr << endl;

    return 0;
}
        </code></pre>
        <p><strong>Output:</strong></p>
        <pre><code>
First element: 10
Second element: 20
Fourth element: 40
        </code></pre>

        <h3>Null Pointer</h3>
        <p>A <strong>null pointer</strong> is a pointer that does not point to any valid memory location. The <code>nullptr</code> keyword (introduced in C++11) is used to initialize a pointer to null.</p>
        <pre><code>
int *ptr = nullptr; // Null pointer initialization

if (ptr == nullptr) {
    cout << "Pointer is null!" << endl;
}
        </code></pre>
        <p><strong>Output:</strong></p>
        <pre><code>
Pointer is null!
        </code></pre>
    </section>

    <section>
        <h2>Advanced Pointer Topics</h2>
        
        <h3>Pointer to Array</h3>
        <p>In C++, arrays and pointers are closely related. An array name is essentially a pointer to the first element of the array. You can treat arrays like pointers, and you can use pointer arithmetic to access elements of the array.</p>

        <p>Example of accessing array elements using pointers:</p>
        <pre><code>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;  // Pointer to the first element of the array

    // Accessing elements using pointer arithmetic
    for (int i = 0; i < 5; ++i) {
        cout << *(ptr + i) << " "; // Dereferencing the pointer
    }

    return 0;
}
        </code></pre>
        <p><strong>Output:</strong></p>
        <pre><code>
10 20 30 40 50
        </code></pre>

        <h3>Pointer to Function</h3>
        <p>Function pointers in C++ allow you to store the address of a function in a pointer variable. This allows functions to be passed as arguments and enables callback functions and dynamic function calling.</p>

        <pre><code>
#include &lt;iostream&gt;
using namespace std;

// Function prototype
void greet();

int main() {
    void (*ptr)();  // Function pointer declaration
    ptr = greet;    // Assign the address of 'greet' function to the pointer

    // Calling function using pointer
    ptr();

    return 0;
}

void greet() {
    cout << "Hello, Pointer to Function!" << endl;
}
        </code></pre>
        <p><strong>Output:</strong></p>
        <pre><code>
Hello, Pointer to Function!
        </code></pre>

        <h3>Dynamic Memory Allocation</h3>
        <p>C++ provides <code>new</code> and <code>delete</code> operators for dynamic memory allocation, allowing you to allocate memory at runtime and deallocate it when done.</p>

        <pre><code>
int *ptr = new int;  // Dynamically allocate memory for an integer
*ptr = 50;  // Assign value
cout << "Dynamically allocated value: " << *ptr << endl;
delete ptr;  // Deallocate memory
        </code></pre>

        <p><strong>Output:</strong></p>
        <pre><code>
Dynamically allocated value: 50
        </code></pre>

        <p>It is important to use <code>delete</code> to free dynamically allocated memory to avoid memory leaks.</p>
    </section>

    <footer>
        <p>Â© By Coding Hub. All Rights Reserved.</p>
    </footer>

</body>
</html>
