<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion in C++ - Detailed Explanation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f4f4f4;
            color: #333;
        }
        header {
            background: #0078d7;
            color: #fff;
            padding: 20px 10px;
            text-align: center;
        }
        header h1 {
            margin: 0;
            font-size: 2.5em;
        }
        section {
            padding: 20px;
            max-width: 1200px;
            margin: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #0078d7;
            margin-top: 0;
        }
        pre {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        footer {
            text-align: center;
            padding: 10px;
            background: #0078d7;
            color: #fff;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <header>
        <h1>Recursion in C++ - Detailed Explanation</h1>
    </header>

    <section>
        <h2>1. Introduction to Recursion</h2>
        <p>Recursion is a powerful technique in programming where a function calls itself in order to solve smaller instances of the same problem. It is widely used to solve problems that can be broken down into simpler sub-problems, such as calculating factorials, generating Fibonacci sequences, tree traversals, and many more.</p>
        <p>Recursion is based on two key concepts:</p>
        <ul>
            <li><strong>Base Case</strong>: The condition under which the recursion stops. It prevents the function from calling itself indefinitely.</li>
            <li><strong>Recursive Case</strong>: The part where the function calls itself with modified arguments, breaking the problem into smaller sub-problems.</li>
        </ul>

        <h2>2. Recursive Function Example: Factorial</h2>
        <p>The factorial of a number <code>n</code> is the product of all integers from 1 to <code>n</code>. In mathematical notation:</p>
        <pre><code>
n! = n * (n - 1) * (n - 2) * ... * 1
        </code></pre>

        <h3>2.1 Recursive Factorial Function</h3>
        <pre><code>
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n <= 1) {
        return 1;  // Base case
    }
    return n * factorial(n - 1);  // Recursive case
}

int main() {
    int number = 5;
    cout << "Factorial of " << number << " is " << factorial(number) << endl;
    return 0;
}
        </code></pre>

        <h3>2.2 Explanation of the Code</h3>
        <ul>
            <li>The function <code>factorial</code> checks if <code>n</code> is 1 or less (base case). If so, it returns 1, terminating the recursion.</li>
            <li>If the base case is not met, the function multiplies <code>n</code> by the result of <code>factorial(n - 1)</code>, which recursively calls the function until the base case is reached.</li>
        </ul>

        <h3>2.3 Output</h3>
        <pre><code>
Factorial of 5 is 120
        </code></pre>

        <h2>3. Visualizing Recursion: Recursion Tree</h2>
        <p>Recursion can be visualized as a tree structure, where each node represents a function call. The tree branches out, with each branch representing a recursive call. The depth of the tree increases with the number of recursive calls.</p>

        <h3>3.1 Example of Recursion Tree for Factorial(5)</h3>
        <p>For the function call <code>factorial(5)</code>, the recursion tree looks like this:</p>
        <pre><code>
factorial(5)
    |
factorial(4)
    |
factorial(3)
    |
factorial(2)
    |
factorial(1)  --> Base case (returns 1)
        </code></pre>
        <p>Each call waits for the result of the next function call until it reaches the base case.</p>

        <h2>4. Types of Recursion</h2>
        <h3>4.1 Direct Recursion</h3>
        <p>Direct recursion occurs when a function calls itself directly in its body.</p>
        <pre><code>
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);  // Direct recursion
}
        </code></pre>

        <h3>4.2 Indirect Recursion</h3>
        <p>Indirect recursion happens when function A calls function B, and function B calls function A, leading to a recursive cycle between functions.</p>
        <pre><code>
void functionA(int n);
void functionB(int n);

void functionA(int n) {
    if (n > 0) {
        cout << n << " ";
        functionB(n - 1);  // Calls functionB
    }
}

void functionB(int n) {
    if (n > 0) {
        cout << n << " ";
        functionA(n - 1);  // Calls functionA
    }
}

int main() {
    functionA(5);  // This will alternate between functionA and functionB
    return 0;
}
        </code></pre>

        <h3>4.3 Output of Indirect Recursion</h3>
        <pre><code>
5 4 3 2 1 1 2 3 4 5
        </code></pre>

        <h2>5. Advantages and Disadvantages of Recursion</h2>
        <h3>5.1 Advantages</h3>
        <ul>
            <li>Recursion simplifies code for problems that can be broken down into similar sub-problems.</li>
            <li>It makes code more readable, especially for problems like tree traversal and dynamic programming.</li>
            <li>Recursion is easier to implement for problems with inherently recursive structures, like parsing and divide-and-conquer algorithms.</li>
        </ul>

        <h3>5.2 Disadvantages</h3>
        <ul>
            <li>Recursion can lead to high memory usage due to the stack overhead with each recursive call.</li>
            <li>Recursive functions can be less efficient compared to iterative solutions, especially for simple problems.</li>
            <li>Deep recursion can result in stack overflow if the recursion depth is too large.</li>
        </ul>

        <h2>6. Recursion Depth and Stack Overflow</h2>
        <p>Every recursive call adds a new frame to the call stack. The maximum depth of recursion is limited by the available stack space. If a function calls itself too many times without reaching the base case, the stack will overflow, resulting in a runtime error.</p>

        <h3>6.1 Example of Stack Overflow</h3>
        <pre><code>
#include <iostream>
using namespace std;

void infiniteRecursion() {
    infiniteRecursion();  // Infinite recursive call
}

int main() {
    infiniteRecursion();  // This will lead to stack overflow
    return 0;
}
        </code></pre>

        <h3>6.2 Output</h3>
        <pre><code>
Stack overflow error
        </code></pre>

        <h2>7. Tail Recursion and Optimization</h2>
        <p>In tail recursion, the recursive call is the last operation in the function. This allows for an optimization called tail-call optimization (TCO), where the compiler reuses the current stack frame, preventing new stack frames from being created. This optimization avoids stack overflow and improves performance.</p>

        <h3>7.1 Tail Recursion Example</h3>
        <pre><code>
#include <iostream>
using namespace std;

int factorial_tail(int n, int result = 1) {
    if (n <= 1) {
        return result;
    }
    return factorial_tail(n - 1, n * result);  // Tail recursion
}

int main() {
    int number = 5;
    cout << "Factorial of " << number << " using tail recursion is " << factorial_tail(number) << endl;
    return 0;
}
        </code></pre>

        <h3>7.2 Output</h3>
        <pre><code>
Factorial of 5 using tail recursion is 120
        </code></pre>

        <h2>8. Recursion vs Iteration</h2>
        <p>While both recursion and iteration can solve the same types of problems, they do so in different ways. Recursion is elegant and easy to implement for problems with a recursive structure, like tree traversal or graph searching. However, recursion often uses more memory due to the call stack.</p>
        <p>Iteration, on the other hand, is often more efficient in terms of memory usage because it does not rely on the call stack. For problems that can be solved with loops, iteration is generally preferred.</p>

        <footer>
            <p>Â© By Coding Hub. All Rights Reserved.</p>
        </footer>
    </section>

</body>
</html>
